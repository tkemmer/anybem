struct BornIon {
	charge: Charge,
	radius: Real
}

static born_li = BornIon{charge: Charge{pos: origin, val: 1 as Real}, radius: 0.645 as Real};
static born_na = BornIon{charge: Charge{pos: origin, val: 1 as Real}, radius: 1.005 as Real};
static born_k  = BornIon{charge: Charge{pos: origin, val: 1 as Real}, radius: 1.365 as Real};
static born_rb = BornIon{charge: Charge{pos: origin, val: 1 as Real}, radius: 1.505 as Real};
static born_cs = BornIon{charge: Charge{pos: origin, val: 1 as Real}, radius: 1.715 as Real};
static born_mg = BornIon{charge: Charge{pos: origin, val: 2 as Real}, radius: 0.615 as Real};
static born_ca = BornIon{charge: Charge{pos: origin, val: 2 as Real}, radius: 1.015 as Real};
static born_sr = BornIon{charge: Charge{pos: origin, val: 2 as Real}, radius: 1.195 as Real};
static born_ba = BornIon{charge: Charge{pos: origin, val: 2 as Real}, radius: 1.385 as Real};

fn born_extpot_local(pos: &Position, ion: &BornIon, opt: &SystemParams) -> Real {
	potpref * (*ion).charge.val / (*opt).epsSigma / euclidean(pos, (*ion).charge.pos)
}

fn born_extpot_nonlocal(pos: &Position, ion: &BornIon, opt: &SystemParams) -> Real {
	let r  = euclidean(pos, (*ion).charge.pos);
	let nu = sqrt((*opt).epsSigma / (*opt).epsInf) * (*ion).radius / (*opt).lambda;
	potpref * (*ion).charge.val/(*opt).epsSigma/r * (one + ((*opt).epsSigma - (*opt).epsInf) /
		(*opt).epsInf * sinh(nu)/nu * exp(-nu * (*ion).radius))
}

fn born_intpot_local(pos: &Position, ion: &BornIon, opt: &SystemParams) -> Real {
	potpref * (*ion).charge.val *
		(one/euclidean(pos, (*ion).charge.pos) + one/(*ion).radius * (one/(*opt).epsSigma - one))
}

fn born_intpot_nonlocal(pos: &Position, ion: &BornIon, opt: &SystemParams) -> Real {
	let r  = euclidean(pos, (*ion).charge.pos);
	let nu = sqrt((*opt).epsSigma/(*opt).epsInf) * (*ion).radius / (*opt).lambda;
	potpref * (*ion).charge.val * (one/r + one/(*ion).radius/(*opt).epsSigma *
		(one - (*opt).epsSigma + ((*opt).epsSigma - (*opt).epsInf)/(*opt).epsInf * sinh(nu)/nu * exp(-nu)))
}
