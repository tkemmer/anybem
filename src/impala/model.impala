// ====================================================================================================================
// Nodes

struct Node {
	pos: fn() -> Position,
	x:   fn() -> Real,
	y:   fn() -> Real,
	z:   fn() -> Real
}

type NodePrimitive = Position;

struct NodeBuffer {
	device: fn()      -> i32,
	get:    fn(Index) -> Node,
	memory: fn()      -> i64,
	size:   fn()      -> Index
}

struct NodeBufferPrimitive {
	buf: Buffer,
	len: Index
}

struct NodeBufferPrototype {
	data: &[NodePrimitive],
	len:  Index
}

fn new_node(node: NodePrimitive) -> Node {
	Node {
		pos: || node,
		x:   || node(0),
		y:   || node(1),
		z:   || node(2)
	}
}

fn new_node_buffer(nodes: NodeBufferPrimitive) -> NodeBuffer {
	NodeBuffer {
		device: ||    nodes.buf.device,
		get:    |idx| new_node(bitcast[&[NodePrimitive]](nodes.buf.data)(idx)),
		memory: ||    nodes.buf.size,
		size:   ||    nodes.len
	}
}

fn to_node_buffer(proto: NodeBufferPrototype) -> NodeBuffer {
	let buf = Buffer {
		device: 0,
		data:   bitcast[&[i8]](proto.data),
		size:   (proto.len as i64) * (sizeof[NodePrimitive]() as i64)
	};
	let nodes = NodeBufferPrimitive {
		buf: buf,
		len: proto.len
	};
	new_node_buffer(nodes)
}

fn dump_node_buffer(nodes: NodeBuffer, head_max: i32) -> () {
	print_string("Node buffer stats:\n");
	print_string(" * Device: "); print_i32(nodes.device()); print_string("\n");
	print_string(" * Length: "); print_i64(nodes.size() as i64); print_string(" nodes\n");
	print_string(" * Memory: "); print_i64(nodes.memory()); print_string(" bytes\n");
	print_string(" * Head:\n");
	for i in range(0, math.min(nodes.size() as i32, head_max)) {
		let node = nodes.get(i as Index);
		print_string("    - Node ");
		print_i32(i);
		print_string(": {");
		print_f64(node.x() as f64);
		print_string(", ");
		print_f64(node.y() as f64);
		print_string(", ");
		print_f64(node.z() as f64);
		print_string("}\n");
	}
}


// ====================================================================================================================
// Elements

struct Triangle {
	v1:     Index,
	v2:     Index,
	v3:     Index
}

struct TriangleBuffer {
	buf: Buffer,
	len: Index
}

struct TriangleBufferPrototype {
	data: &[Triangle],
	len:  Index
}

fn new_triangle_buffer(buf: Buffer, len: Index) -> TriangleBuffer {
	TriangleBuffer {
		buf: buf,
		len: len
	}
}

fn to_triangle_buffer(elements: TriangleBufferPrototype) -> TriangleBuffer {
	let buf = Buffer {
		device: 0,
		data:   bitcast[&[i8]](elements.data),
		size:   (elements.len as i64) * (sizeof[Triangle]() as i64)
	};
	new_triangle_buffer(buf, elements.len)
}

fn dump_triangle_buffer(elements: TriangleBuffer, head_max: i32) -> () {
	print_string("Surface element buffer stats:\n");
	print_string(" * Device: "); print_i32(elements.buf.device); print_string("\n");
	print_string(" * Length: "); print_i64(elements.len as i64); print_string(" elements\n");
	print_string(" * Memory: "); print_i64(elements.buf.size); print_string(" bytes\n");
	print_string(" * Head:\n");
	let data = bitcast[&[SurfaceElement]](elements.buf.data);
	for i in range(0, math.min(elements.len as i32, head_max)) {
		print_string("    - Element ");
		print_i32(i);
		print_string(": {");
		print_i64((*data)(i).v1 as i64);
		print_string(", ");
		print_i64((*data)(i).v2 as i64);
		print_string(", ");
		print_i64((*data)(i).v3 as i64);
		print_string("}\n");
	}
}

type SurfaceElement = Triangle;
type SurfaceElementBuffer = TriangleBuffer;
type SurfaceElementBufferPrototype = TriangleBufferPrototype;

fn new_surface_element_buffer(buf: Buffer, len: Index) -> SurfaceElementBuffer {
	new_triangle_buffer(buf, len)
}

fn to_surface_element_buffer(elements: TriangleBufferPrototype) -> SurfaceElementBuffer {
	to_triangle_buffer(elements)
}

fn dump_surface_element_buffer(elements: SurfaceElementBuffer, head_max: i32) -> () {
	dump_triangle_buffer(elements, head_max)
}


// ====================================================================================================================
// Charges

struct Charge {
	pos: Position,
	val: Real
}

struct ChargeBuffer {
	buf: Buffer,
	len: Index
}

struct ChargeBufferPrototype {
	data: &[Charge],
	len:  Index
}

fn new_charge_buffer(buf: Buffer, len: Index) -> ChargeBuffer {
	ChargeBuffer {
		buf: buf,
		len: len
	}
}

fn to_charge_buffer(charges: ChargeBufferPrototype) -> ChargeBuffer {
	let buf = Buffer {
		device: 0,
		data:   bitcast[&[i8]](charges.data),
		size:   (charges.len as i64) * (sizeof[Charge]() as i64)
	};
	new_charge_buffer(buf, charges.len)
}

fn dump_charge_buffer(charges: ChargeBuffer, head_max: i32) -> () {
	print_string("Charge buffer stats:\n");
	print_string(" * Device: "); print_i32(charges.buf.device); print_string("\n");
	print_string(" * Length: "); print_i64(charges.len as i64); print_string(" charges\n");
	print_string(" * Memory: "); print_i64(charges.buf.size); print_string(" bytes\n");
	print_string(" * Head:\n");
	let data = bitcast[&[Charge]](charges.buf.data);
	for i in range(0, math.min(charges.len as i32, head_max)) {
		print_string("    - Charge ");
		print_i32(i);
		print_string(": { {");
		print_f64((*data)(i).pos(0) as f64);
		print_string(", ");
		print_f64((*data)(i).pos(1) as f64);
		print_string(", ");
		print_f64((*data)(i).pos(2) as f64);
		print_string("}, ");
		print_f64((*data)(i).val as f64);
		print_string("}\n");
	}
}


// ====================================================================================================================
// System parameters

struct SystemParams {
	epsOmega: Real,
	epsSigma: Real,
	epsInf:   Real,
	lambda:   Real
}

fn dump_system_params(params: SystemParams) -> () {
	print_string("System parameters:\n");
	print_string(" * epsOmega: "); print_f64(params.epsOmega as f64); print_string("\n");
	print_string(" * epsSigma: "); print_f64(params.epsSigma as f64); print_string("\n");
	print_string(" * epsInf:   "); print_f64(params.epsInf as f64); print_string("\n");
	print_string(" * lambda:   "); print_f64(params.lambda as f64); print_string("\n");
}


// ====================================================================================================================
// Surface model

struct SurfaceModel {
	nodes:    NodeBuffer,
	elements: SurfaceElementBuffer,
	charges:  ChargeBuffer,
	params:   SystemParams
}

struct SurfaceModelPrototype {
	nodes:    NodeBufferPrototype,
	elements: SurfaceElementBufferPrototype,
	charges:  ChargeBufferPrototype,
	params:   SystemParams
}

fn new_surface_model(
		nodes: NodeBuffer,
		elements: SurfaceElementBuffer,
		charges: ChargeBuffer,
		params: SystemParams
	) -> SurfaceModel {
	SurfaceModel {
		nodes:    nodes,
		elements: elements,
		charges:  charges,
		params:   params
	}
}

fn to_surface_model(surf: SurfaceModelPrototype) -> SurfaceModel {
	new_surface_model(
		to_node_buffer(surf.nodes),
		to_surface_element_buffer(surf.elements),
		to_charge_buffer(surf.charges),
		surf.params
	)
}
