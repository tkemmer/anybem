// ====================================================================================================================
// Nodes

struct Node {
	pos: fn() -> Position,
	x:   fn() -> Real,
	y:   fn() -> Real,
	z:   fn() -> Real
}

type NodePrimitive = Position;

struct NodeBuffer {
	device: fn()      -> i32,
	get:    fn(Index) -> Node,
	memory: fn()      -> i64,
	size:   fn()      -> Index
}

struct NodeBufferPrimitive {
	buf: Buffer,
	len: Index
}

struct NodeBufferPrototype {
	data: &[NodePrimitive],
	len:  Index
}

fn new_node(node: NodePrimitive) -> Node {
	Node {
		pos: || node,
		x:   || node.x,
		y:   || node.y,
		z:   || node.z
	}
}

fn new_node_buffer(nodes: NodeBufferPrimitive) -> NodeBuffer {
	NodeBuffer {
		device: ||    nodes.buf.device,
		get:    |idx| new_node(bitcast[&[NodePrimitive]](nodes.buf.data)(idx)),
		memory: ||    nodes.buf.size,
		size:   ||    nodes.len
	}
}

fn to_node_buffer(proto: NodeBufferPrototype) -> NodeBuffer {
	let buf = Buffer {
		device: 0,
		data:   bitcast[&[i8]](proto.data),
		size:   (proto.len as i64) * (sizeof[NodePrimitive]() as i64)
	};
	let nodes = NodeBufferPrimitive {
		buf: buf,
		len: proto.len
	};
	new_node_buffer(nodes)
}

fn dump_node_buffer(nodes: NodeBuffer, head_max: i32) -> () {
	print_string("Node buffer stats:\n");
	print_string(" * Device: "); print_i32(nodes.device()); print_string("\n");
	print_string(" * Size:   "); print_index(nodes.size()); print_string(" nodes\n");
	print_string(" * Memory: "); print_i64(nodes.memory()); print_string(" bytes\n");
	print_string(" * Head:\n");
	for i in range(0, math.min(nodes.size() as i32, head_max)) {
		let node = nodes.get(i as Index);
		print_string("    - Node ");
		print_i32(i);
		print_string(": {");
		print_real(node.x());
		print_string(", ");
		print_real(node.y());
		print_string(", ");
		print_real(node.z());
		print_string("}\n");
	}
}


// ====================================================================================================================
// Elements

struct Triangle {
	v1:     fn() -> Node,       // first node
	v2:     fn() -> Node,       // second node
	v3:     fn() -> Node,       // third node
	center: fn() -> Position,   // centroid
	normal: fn() -> Position,   // unit normal vector
	area:   fn() -> Real,       // surface area
	dist:   fn() -> Real        // distance to origin
}

struct TrianglePrimitive {
	v1:     Index,
	v2:     Index,
	v3:     Index
}

struct TriangleBuffer {
	device: fn()      -> i32,
	get:    fn(Index) -> Triangle,
	memory: fn()      -> i64,
	size:   fn()      -> Index
}

struct TriangleBufferPrimitive {
	buf: Buffer,
	len: Index
}

struct TriangleBufferPrototype {
	data: &[TrianglePrimitive],
	len:  Index
}

fn new_triangle(elem: TrianglePrimitive, nodes: NodeBuffer) -> Triangle {
	let v1 = nodes.get(elem.v1);
	let v2 = nodes.get(elem.v2);
	let v3 = nodes.get(elem.v3);
	let unscaled_normal = cross(
		sub(v2.pos(), v1.pos()),
		sub(v3.pos(), v1.pos())
	);
	let vnorm = vecnorm(unscaled_normal);
	let unit_normal = sdiv(unscaled_normal, vnorm);
	Triangle {
		v1:     || v1,
		v2:     || v2,
		v3:     || v3,
		center: || sdiv(add(v1.pos(), add(v2.pos(), v3.pos())), 3 as Real),
		normal: || unit_normal,
		area:   || vnorm / 2 as Real,
		dist:   || dot(unit_normal, v1.pos())
	}
}

fn new_triangle_buffer(elements: TriangleBufferPrimitive, nodes: NodeBuffer) -> TriangleBuffer {
	TriangleBuffer {
		device: ||    elements.buf.device,
		get:    |idx| new_triangle(bitcast[&[TrianglePrimitive]](elements.buf.data)(idx), nodes),
		memory: ||    elements.buf.size,
		size:   ||    elements.len
	}
}

fn to_triangle_buffer(proto: TriangleBufferPrototype, nodes: NodeBuffer) -> TriangleBuffer {
	let buf = Buffer {
		device: 0,
		data:   bitcast[&[i8]](proto.data),
		size:   (proto.len as i64) * (sizeof[TrianglePrimitive]() as i64)
	};
	let elements = TriangleBufferPrimitive {
		buf: buf,
		len: proto.len
	};
	new_triangle_buffer(elements, nodes)
}

fn dump_triangle_buffer(elements: TriangleBuffer, head_max: i32) -> () {
	print_string("Surface element buffer stats:\n");
	print_string(" * Device: "); print_i32(elements.device()); print_string("\n");
	print_string(" * Size:   "); print_index(elements.size()); print_string(" elements\n");
	print_string(" * Memory: "); print_i64(elements.memory()); print_string(" bytes\n");
	print_string(" * Head:\n");
	for i in range(0, math.min(elements.size() as i32, head_max)) {
		let elem = elements.get(i as Index);
		print_string("    - Element ");
		print_i32(i);
		print_string(":\n");
		print_string("       - v1:     {");
		print_real(elem.v1().x()); print_string(", ");
		print_real(elem.v1().y()); print_string(", ");
		print_real(elem.v1().z());
		print_string("}\n");
		print_string("       - v2:     {");
		print_real(elem.v2().x()); print_string(", ");
		print_real(elem.v2().y()); print_string(", ");
		print_real(elem.v2().z());
		print_string("}\n");
		print_string("       - v3:     {");
		print_real(elem.v3().x()); print_string(", ");
		print_real(elem.v3().y()); print_string(", ");
		print_real(elem.v3().z());
		print_string("}\n");
		print_string("       - center: {");
		print_real(elem.center().x); print_string(", ");
		print_real(elem.center().y); print_string(", ");
		print_real(elem.center().z);
		print_string("}\n");
		print_string("       - normal: {");
		print_real(elem.normal().x); print_string(", ");
		print_real(elem.normal().y); print_string(", ");
		print_real(elem.normal().z);
		print_string("}\n");
		print_string("       - area:   "); print_real(elem.area()); print_string("\n");
		print_string("       - dist:   "); print_real(elem.dist()); print_string("\n");
	}
}

type SurfaceElement = Triangle;
type SurfaceElementPrimitive = TrianglePrimitive;
type SurfaceElementBuffer = TriangleBuffer;
type SurfaceElementBufferPrimitive = TriangleBufferPrimitive;
type SurfaceElementBufferPrototype = TriangleBufferPrototype;

fn new_surface_element(elem: SurfaceElementPrimitive, nodes: NodeBuffer) -> SurfaceElement {
	new_triangle(elem, nodes)
}

fn new_surface_element_buffer(elements: SurfaceElementBufferPrimitive, nodes: NodeBuffer) -> SurfaceElementBuffer {
	new_triangle_buffer(elements, nodes)
}

fn to_surface_element_buffer(proto: SurfaceElementBufferPrototype, nodes: NodeBuffer) -> SurfaceElementBuffer {
	to_triangle_buffer(proto, nodes)
}

fn dump_surface_element_buffer(elements: SurfaceElementBuffer, head_max: i32) -> () {
	dump_triangle_buffer(elements, head_max)
}


// ====================================================================================================================
// Charges

struct Charge {
	pos: fn() -> Position,
	val: fn() -> Real
}

struct ChargePrimitive {
	pos: Position,
	val: Real
}

struct ChargeBuffer {
	device: fn()      -> i32,
	get:    fn(Index) -> Charge,
	memory: fn()      -> i64,
	size:   fn()      -> Index
}

struct ChargeBufferPrimitive {
	buf: Buffer,
	len: Index
}

struct ChargeBufferPrototype {
	data: &[ChargePrimitive],
	len:  Index
}

fn new_charge(charge: ChargePrimitive) -> Charge {
	Charge {
		pos: || charge.pos,
		val: || charge.val
	}
}

fn new_charge_buffer(charges: ChargeBufferPrimitive) -> ChargeBuffer {
	ChargeBuffer {
		device: ||    charges.buf.device,
		get:    |idx| new_charge(bitcast[&[ChargePrimitive]](charges.buf.data)(idx)),
		memory: ||    charges.buf.size,
		size:   ||    charges.len
	}
}

fn to_charge_buffer(proto: ChargeBufferPrototype) -> ChargeBuffer {
	let buf = Buffer {
		device: 0,
		data:   bitcast[&[i8]](proto.data),
		size:   (proto.len as i64) * (sizeof[ChargePrimitive]() as i64)
	};
	let charges = ChargeBufferPrimitive {
		buf: buf,
		len: proto.len
	};
	new_charge_buffer(charges)
}

fn dump_charge_buffer(charges: ChargeBuffer, head_max: i32) -> () {
	print_string("Charge buffer stats:\n");
	print_string(" * Device: "); print_i32(charges.device()); print_string("\n");
	print_string(" * Size:   "); print_index(charges.size()); print_string(" charges\n");
	print_string(" * Memory: "); print_i64(charges.memory()); print_string(" bytes\n");
	print_string(" * Head:\n");
	for i in range(0, math.min(charges.size() as i32, head_max)) {
		let charge = charges.get(i as Index);
		print_string("    - Charge ");
		print_i32(i);
		print_string(": { {");
		print_real(charge.pos().x);
		print_string(", ");
		print_real(charge.pos().y);
		print_string(", ");
		print_real(charge.pos().z);
		print_string("}, ");
		print_real(charge.val());
		print_string("}\n");
	}
}


// ====================================================================================================================
// System parameters

struct SystemParams {
	epsOmega: Real,
	epsSigma: Real,
	epsInf:   Real,
	lambda:   Real
}

static default_params = SystemParams{
	epsOmega: 2   as Real,
	epsSigma: 78  as Real,
	epsInf:   1.8 as Real,
	lambda:   20  as Real
};

fn dump_system_params(params: SystemParams) -> () {
	print_string("System parameters:\n");
	print_string(" * epsOmega: "); print_real(params.epsOmega); print_string("\n");
	print_string(" * epsSigma: "); print_real(params.epsSigma); print_string("\n");
	print_string(" * epsInf:   "); print_real(params.epsInf); print_string("\n");
	print_string(" * lambda:   "); print_real(params.lambda); print_string("\n");
}


// ====================================================================================================================
// Surface model

struct SurfaceModel {
	nodes:    fn() -> NodeBuffer,
	elements: fn() -> SurfaceElementBuffer,
	charges:  fn() -> ChargeBuffer,
	params:   fn() -> SystemParams
}

struct SurfaceModelPrimitive {
	nodes:    NodeBuffer,
	elements: SurfaceElementBuffer,
	charges:  ChargeBuffer,
	params:   SystemParams
}

struct SurfaceModelPrototype {
	nodes:    NodeBufferPrototype,
	elements: SurfaceElementBufferPrototype,
	charges:  ChargeBufferPrototype,
	params:   SystemParams
}

fn new_surface_model(surf: SurfaceModelPrimitive) -> SurfaceModel {
	SurfaceModel {
		nodes:    || surf.nodes,
		elements: || surf.elements,
		charges:  || surf.charges,
		params:   || surf.params
	}
}

fn to_surface_model(proto: SurfaceModelPrototype) -> SurfaceModel {
	let nodes = to_node_buffer(proto.nodes);
	let surf = SurfaceModelPrimitive {
		nodes:    nodes,
		elements: to_surface_element_buffer(proto.elements, nodes),
		charges:  to_charge_buffer(proto.charges),
		params:   proto.params
	};
	new_surface_model(surf)
}
