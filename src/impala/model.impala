// ====================================================================================================================
// Nodes

struct Node {
	pos: fn() -> Position,
	x:   fn() -> Real,
	y:   fn() -> Real,
	z:   fn() -> Real
}

struct NodePrimitive {
	x: Real,
	y: Real,
	z: Real
}

struct NodeBuffer {
	device: fn()      -> i32,
	get:    fn(Index) -> Node,
	memory: fn()      -> i64,
	size:   fn()      -> Index
}

struct NodeBufferPrimitive {
	buf: Buffer,
	len: Index
}

struct NodeBufferPrototype {
	data: &[NodePrimitive],
	len:  Index
}

fn new_node(node: NodePrimitive) -> Node {
	Node {
		pos: || [node.x, node.y, node.z],
		x:   || node.x,
		y:   || node.y,
		z:   || node.z
	}
}

fn new_node_buffer(nodes: NodeBufferPrimitive) -> NodeBuffer {
	NodeBuffer {
		device: ||    nodes.buf.device,
		get:    |idx| new_node(bitcast[&[NodePrimitive]](nodes.buf.data)(idx)),
		memory: ||    nodes.buf.size,
		size:   ||    nodes.len
	}
}

fn to_node_buffer(proto: NodeBufferPrototype) -> NodeBuffer {
	let buf = Buffer {
		device: 0,
		data:   bitcast[&[i8]](proto.data),
		size:   (proto.len as i64) * (sizeof[NodePrimitive]() as i64)
	};
	let nodes = NodeBufferPrimitive {
		buf: buf,
		len: proto.len
	};
	new_node_buffer(nodes)
}

fn dump_node_buffer(nodes: NodeBuffer, head_max: i32) -> () {
	print_string("Node buffer stats:\n");
	print_string(" * Device: "); print_i32(nodes.device()); print_string("\n");
	print_string(" * Length: "); print_i64(nodes.size() as i64); print_string(" nodes\n");
	print_string(" * Memory: "); print_i64(nodes.memory()); print_string(" bytes\n");
	print_string(" * Head:\n");
	for i in range(0, math.min(nodes.size() as i32, head_max)) {
		let node = nodes.get(i as Index);
		print_string("    - Node ");
		print_i32(i);
		print_string(": {");
		print_f64(node.x() as f64);
		print_string(", ");
		print_f64(node.y() as f64);
		print_string(", ");
		print_f64(node.z() as f64);
		print_string("}\n");
	}
}


// ====================================================================================================================
// Elements

struct Triangle {
	v1:     fn() -> Node,       // first node
	v2:     fn() -> Node,       // second node
	v3:     fn() -> Node,       // third node
	center: fn() -> Position,   // centroid
	normal: fn() -> Position,   // unit normal vector
	area:   fn() -> Real,       // surface area
	dist:   fn() -> Real        // distance to origin
}

struct TrianglePrimitive {
	v1:     Index,
	v2:     Index,
	v3:     Index
}

struct TriangleBuffer {
	device: fn()      -> i32,
	get:    fn(Index) -> Triangle,
	memory: fn()      -> i64,
	size:   fn()      -> Index
}

struct TriangleBufferPrimitive {
	buf: Buffer,
	len: Index
}

struct TriangleBufferPrototype {
	data: &[TrianglePrimitive],
	len:  Index
}

fn new_triangle(elem: TrianglePrimitive, nodes: NodeBuffer) -> Triangle {
	Triangle {
		v1:     || nodes.get(elem.v1),
		v2:     || nodes.get(elem.v2),
		v3:     || nodes.get(elem.v3),
		center: || origin, // FIXME
		normal: || origin, // FIXME
		area:   || zero,   // FIXME
		dist:   || zero    // FIXME
	}
}

fn new_triangle_buffer(elements: TriangleBufferPrimitive, nodes: NodeBuffer) -> TriangleBuffer {
	TriangleBuffer {
		device: ||    elements.buf.device,
		get:    |idx| new_triangle(bitcast[&[TrianglePrimitive]](elements.buf.data)(idx), nodes),
		memory: ||    elements.buf.size,
		size:   ||    elements.len
	}
}

fn to_triangle_buffer(proto: TriangleBufferPrototype, nodes: NodeBuffer) -> TriangleBuffer {
	let buf = Buffer {
		device: 0,
		data:   bitcast[&[i8]](proto.data),
		size:   (proto.len as i64) * (sizeof[TrianglePrimitive]() as i64)
	};
	let elements = TriangleBufferPrimitive {
		buf: buf,
		len: proto.len
	};
	new_triangle_buffer(elements, nodes)
}

fn dump_triangle_buffer(elements: TriangleBuffer, head_max: i32) -> () {
	print_string("Surface element buffer stats:\n");
	print_string(" * Device: "); print_i32(elements.device()); print_string("\n");
	print_string(" * Length: "); print_i64(elements.size() as i64); print_string(" elements\n");
	print_string(" * Memory: "); print_i64(elements.memory()); print_string(" bytes\n");
	print_string(" * Head:\n");
	for i in range(0, math.min(elements.size() as i32, head_max)) {
		let elem = elements.get(i as Index);
		print_string("    - Element ");
		print_i32(i);
		print_string(": { {");
		print_f64(elem.v1().x() as f64); print_string(", ");
		print_f64(elem.v1().y() as f64); print_string(", ");
		print_f64(elem.v1().z() as f64);
		print_string("}, {");
		print_f64(elem.v2().x() as f64); print_string(", ");
		print_f64(elem.v2().y() as f64); print_string(", ");
		print_f64(elem.v2().z() as f64);
		print_string("}, {");
		print_f64(elem.v3().x() as f64); print_string(", ");
		print_f64(elem.v3().y() as f64); print_string(", ");
		print_f64(elem.v3().z() as f64);
		print_string("} }\n");
	}
}

type SurfaceElement = Triangle;
type SurfaceElementPrimitive = TrianglePrimitive;
type SurfaceElementBuffer = TriangleBuffer;
type SurfaceElementBufferPrimitive = TriangleBufferPrimitive;
type SurfaceElementBufferPrototype = TriangleBufferPrototype;

fn new_surface_element(elem: SurfaceElementPrimitive, nodes: NodeBuffer) -> SurfaceElement {
	new_triangle(elem, nodes)
}

fn new_surface_element_buffer(elements: SurfaceElementBufferPrimitive, nodes: NodeBuffer) -> SurfaceElementBuffer {
	new_triangle_buffer(elements, nodes)
}

fn to_surface_element_buffer(proto: SurfaceElementBufferPrototype, nodes: NodeBuffer) -> SurfaceElementBuffer {
	to_triangle_buffer(proto, nodes)
}

fn dump_surface_element_buffer(elements: SurfaceElementBuffer, head_max: i32) -> () {
	dump_triangle_buffer(elements, head_max)
}


// ====================================================================================================================
// Charges

struct Charge {
	pos: Position,
	val: Real
}

struct ChargeBuffer {
	buf: Buffer,
	len: Index
}

struct ChargeBufferPrototype {
	data: &[Charge],
	len:  Index
}

fn new_charge_buffer(buf: Buffer, len: Index) -> ChargeBuffer {
	ChargeBuffer {
		buf: buf,
		len: len
	}
}

fn to_charge_buffer(charges: ChargeBufferPrototype) -> ChargeBuffer {
	let buf = Buffer {
		device: 0,
		data:   bitcast[&[i8]](charges.data),
		size:   (charges.len as i64) * (sizeof[Charge]() as i64)
	};
	new_charge_buffer(buf, charges.len)
}

fn dump_charge_buffer(charges: ChargeBuffer, head_max: i32) -> () {
	print_string("Charge buffer stats:\n");
	print_string(" * Device: "); print_i32(charges.buf.device); print_string("\n");
	print_string(" * Length: "); print_i64(charges.len as i64); print_string(" charges\n");
	print_string(" * Memory: "); print_i64(charges.buf.size); print_string(" bytes\n");
	print_string(" * Head:\n");
	let data = bitcast[&[Charge]](charges.buf.data);
	for i in range(0, math.min(charges.len as i32, head_max)) {
		print_string("    - Charge ");
		print_i32(i);
		print_string(": { {");
		print_f64((*data)(i).pos(0) as f64);
		print_string(", ");
		print_f64((*data)(i).pos(1) as f64);
		print_string(", ");
		print_f64((*data)(i).pos(2) as f64);
		print_string("}, ");
		print_f64((*data)(i).val as f64);
		print_string("}\n");
	}
}


// ====================================================================================================================
// System parameters

struct SystemParams {
	epsOmega: Real,
	epsSigma: Real,
	epsInf:   Real,
	lambda:   Real
}

fn dump_system_params(params: SystemParams) -> () {
	print_string("System parameters:\n");
	print_string(" * epsOmega: "); print_f64(params.epsOmega as f64); print_string("\n");
	print_string(" * epsSigma: "); print_f64(params.epsSigma as f64); print_string("\n");
	print_string(" * epsInf:   "); print_f64(params.epsInf as f64); print_string("\n");
	print_string(" * lambda:   "); print_f64(params.lambda as f64); print_string("\n");
}


// ====================================================================================================================
// Surface model

struct SurfaceModel {
	nodes:    NodeBuffer,
	elements: SurfaceElementBuffer,
	charges:  ChargeBuffer,
	params:   SystemParams
}

struct SurfaceModelPrototype {
	nodes:    NodeBufferPrototype,
	elements: SurfaceElementBufferPrototype,
	charges:  ChargeBufferPrototype,
	params:   SystemParams
}

fn new_surface_model(
		nodes: NodeBuffer,
		elements: SurfaceElementBuffer,
		charges: ChargeBuffer,
		params: SystemParams
	) -> SurfaceModel {
	SurfaceModel {
		nodes:    nodes,
		elements: elements,
		charges:  charges,
		params:   params
	}
}

fn to_surface_model(surf: SurfaceModelPrototype) -> SurfaceModel {
	let nodes = to_node_buffer(surf.nodes);
	new_surface_model(
		nodes,
		to_surface_element_buffer(surf.elements, nodes),
		to_charge_buffer(surf.charges),
		surf.params
	)
}
