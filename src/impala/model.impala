// ====================================================================================================================
// Nodes

type Node = Position;

struct NodeBuffer {
	buf: Buffer,
	len: Index
}

struct NodeBufferPrototype {
	data: &[Node],
	len:  Index
}

fn new_node_buffer(buf: Buffer, len: Index) -> NodeBuffer {
	NodeBuffer {
		buf: buf,
		len: len
	}
}

fn to_node_buffer(nodes: NodeBufferPrototype) -> NodeBuffer {
	let buf = Buffer{
		device: 0,
		data:   bitcast[&[i8]](nodes.data),
		size:   (nodes.len as i64) * (sizeof[Node]() as i64)
	};
	new_node_buffer(buf, nodes.len)
}

fn dump_node_buffer(nodes: NodeBuffer, head_max: i32) -> () {
	print_string("Node buffer stats:\n");
	print_string(" * Device: "); print_i32(nodes.buf.device); print_string("\n");
	print_string(" * Length: "); print_i64(nodes.len as i64); print_string(" nodes\n");
	print_string(" * Memory: "); print_i64(nodes.buf.size); print_string(" bytes\n");
	print_string(" * Head:\n");
	let data = bitcast[&[Node]](nodes.buf.data);
	for i in range(0, math.min(nodes.len as i32, head_max)) {
		print_string("    - Node ");
		print_i32(i);
		print_string(": {");
		print_f64((*data)(i)(0) as f64);
		print_string(", ");
		print_f64((*data)(i)(1) as f64);
		print_string(", ");
		print_f64((*data)(i)(2) as f64);
		print_string("}\n");
	}
}


// ====================================================================================================================
// Elements

struct Triangle {
	v1:     Index,      // first node
	v2:     Index,      // second node
	v3:     Index,      // third node
	center: Position,   // centroid
	normal: Position,   // unit normal vector
	area:   Real,       // surface area
	dist:   Real        // distance to origin
}

struct TriangleBuffer {
	buf: Buffer,
	len: Index
}

struct TriangleBufferPrototype {
	data: &[Triangle],
	len:  Index
}

fn new_triangle_buffer(buf: Buffer, len: Index) -> TriangleBuffer {
	TriangleBuffer {
		buf: buf,
		len: len
	}
}

fn to_triangle_buffer(elements: TriangleBufferPrototype) -> TriangleBuffer {
	let buf = Buffer {
		device: 0,
		data:   bitcast[&[i8]](elements.data),
		size:   (elements.len as i64) * (sizeof[Triangle]() as i64)
	};
	new_triangle_buffer(buf, elements.len)
}

fn dump_triangle_buffer(elements: TriangleBuffer, head_max: i32) -> () {
	print_string("Surface element buffer stats:\n");
	print_string(" * Device: "); print_i32(elements.buf.device); print_string("\n");
	print_string(" * Length: "); print_i64(elements.len as i64); print_string(" elements\n");
	print_string(" * Memory: "); print_i64(elements.buf.size); print_string(" bytes\n");
	print_string(" * Head:\n");
	let data = bitcast[&[SurfaceElement]](elements.buf.data);
	for i in range(0, math.min(elements.len as i32, head_max)) {
		print_string("    - Element ");
		print_i32(i);
		print_string(": {");
		print_i64((*data)(i).v1 as i64);
		print_string(", ");
		print_i64((*data)(i).v2 as i64);
		print_string(", ");
		print_i64((*data)(i).v3 as i64);
		print_string("}\n");
	}
}

type SurfaceElement = Triangle;
type SurfaceElementBuffer = TriangleBuffer;
type SurfaceElementBufferPrototype = TriangleBufferPrototype;

fn new_surface_element_buffer(buf: Buffer, len: Index) -> SurfaceElementBuffer {
	new_triangle_buffer(buf, len)
}

fn to_surface_element_buffer(elements: TriangleBufferPrototype) -> SurfaceElementBuffer {
	to_triangle_buffer(elements)
}

fn dump_surface_element_buffer(elements: SurfaceElementBuffer, head_max: i32) -> () {
	dump_triangle_buffer(elements, head_max)
}


// ====================================================================================================================
// Charges

struct Charge {
	pos: Position,
	val: Real
}

struct ChargeBuffer {
	buf: Buffer,
	len: Index
}

struct ChargeBufferPrototype {
	data: &[Charge],
	len:  Index
}

fn new_charge_buffer(buf: Buffer, len: Index) -> ChargeBuffer {
	ChargeBuffer {
		buf: buf,
		len: len
	}
}

fn to_charge_buffer(charges: ChargeBufferPrototype) -> ChargeBuffer {
	let buf = Buffer {
		device: 0,
		data:   bitcast[&[i8]](charges.data),
		size:   (charges.len as i64) * (sizeof[Charge]() as i64)
	};
	new_charge_buffer(buf, charges.len)
}

fn dump_charge_buffer(charges: ChargeBuffer, head_max: i32) -> () {
	print_string("Charge buffer stats:\n");
	print_string(" * Device: "); print_i32(charges.buf.device); print_string("\n");
	print_string(" * Length: "); print_i64(charges.len as i64); print_string(" charges\n");
	print_string(" * Memory: "); print_i64(charges.buf.size); print_string(" bytes\n");
	print_string(" * Head:\n");
	let data = bitcast[&[Charge]](charges.buf.data);
	for i in range(0, math.min(charges.len as i32, head_max)) {
		print_string("    - Charge ");
		print_i32(i);
		print_string(": { {");
		print_f64((*data)(i).pos(0) as f64);
		print_string(", ");
		print_f64((*data)(i).pos(1) as f64);
		print_string(", ");
		print_f64((*data)(i).pos(2) as f64);
		print_string("}, ");
		print_f64((*data)(i).val as f64);
		print_string("}\n");
	}
}


// ====================================================================================================================
// System parameters

struct SystemParams {
	epsOmega: Real,
	epsSigma: Real,
	epsInf:   Real,
	lambda:   Real
}

fn dump_system_params(params: SystemParams) -> () {
	print_string("System parameters:\n");
	print_string(" * epsOmega: "); print_f64(params.epsOmega as f64); print_string("\n");
	print_string(" * epsSigma: "); print_f64(params.epsSigma as f64); print_string("\n");
	print_string(" * epsInf:   "); print_f64(params.epsInf as f64); print_string("\n");
	print_string(" * lambda:   "); print_f64(params.lambda as f64); print_string("\n");
}


// ====================================================================================================================
// Surface model

struct SurfaceModel {
	nodes:    NodeBuffer,
	elements: SurfaceElementBuffer,
	charges:  ChargeBuffer,
	params:   SystemParams
}

struct SurfaceModelPrototype {
	nodes:         NodeBufferPrototype,
	elements:      SurfaceElementBufferPrototype,
	charges:       ChargeBufferPrototype,
	params:        SystemParams
}

fn new_surface_model(
		nodes: NodeBuffer,
		elements: SurfaceElementBuffer,
		charges: ChargeBuffer,
		params: SystemParams
	) -> SurfaceModel {
	SurfaceModel {
		nodes:    nodes,
		elements: elements,
		charges:  charges,
		params:   params
	}
}

fn to_surface_model(surf: SurfaceModelPrototype) -> SurfaceModel {
	new_surface_model(
		to_node_buffer(surf.nodes),
		to_surface_element_buffer(surf.elements),
		to_charge_buffer(surf.charges),
		surf.params
	)
}
