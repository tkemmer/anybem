type PotentialType = bool;
static Laplace = true;
static ReYukawa = false;

type LocalityType = bool;
static SingleLayer = true;
static DoubleLayer = false;

struct PotentialMatrix {
	pot:      PotentialType,
	loc:      LocalityType,
	xis:      fn()             -> NodeBuffer,
	elements: fn()             -> SurfaceElementBuffer,
	size:     fn()             -> (Index, Index),
	get:      fn(Index, Index) -> Real
}

fn new_laplace_potential_matrix(
	loc:      LocalityType,
	xis:      NodeBuffer,
	elements: SurfaceElementBuffer
) -> PotentialMatrix {
	PotentialMatrix {
		pot:      Laplace,
		loc:      loc,
		xis:      ||    xis,
		elements: ||    elements,
		size:     ||    (xis.size(), elements.size()),
		get:      |i,j| if loc == SingleLayer {
			laplacepot_single(xis.get(i).pos(), elements.get(j))
		} else {
			laplacepot_double(xis.get(i).pos(), elements.get(j))
		}
	}
}

fn new_reyukawa_potential_matrix(
	loc:      LocalityType,
	xis:      NodeBuffer,
	elements: SurfaceElementBuffer,
	yuk:      Real
) -> PotentialMatrix {
	PotentialMatrix {
		pot:      ReYukawa,
		loc:      loc,
		xis:      ||    xis,
		elements: ||    elements,
		size:     ||    (xis.size(), elements.size()),
		get:      |i,j| if loc == SingleLayer {
			reyukawapot_single(xis.get(i).pos(), elements.get(j), yuk)
		} else {
			reyukawapot_double(xis.get(i).pos(), elements.get(j), yuk)
		}
	}
}

fn dump_potential_matrix(mat: PotentialMatrix) -> () {
	let (r, c) = mat.size();
	print_index(r); print_string(" x "); print_index(c);
	if mat.pot == Laplace { print_string(" LaplacePotMatrix"); } else { print_string(" ReYukawaPotMatrix"); }
	if mat.loc == SingleLayer { print_string("{SingleLayer}"); } else { print_string("{DoubleLayer}"); }
	print_string("\n");
}

struct Vector{
	size: fn()            -> Index,
	get:  fn(Index)       -> Real,
	set:  fn(Index, Real) -> ()
}

fn new_vector(buf: Buffer) -> Vector {
	let size = buf.size / (sizeof[Real]() as i64);
	Vector {
		size: @||         size,
		get:  @|idx|      bitcast[&[Real]](buf.data)(idx),
		set:  @|idx, val| bitcast[&mut[Real]](buf.data)(idx) = val
	}
}

fn fill_vector(vec: Vector, val: Real) -> Vector {
	for i in range(0, vec.size() as i32) {
		vec.set(i as Index, val)
	}
	vec
}
