type PotentialType = bool;
static Laplace = true;
static ReYukawa = false;

type LocalityType = bool;
static SingleLayer = true;
static DoubleLayer = false;

struct PotentialMatrix {
	pot:      PotentialType,
	loc:      LocalityType,
	xis:      fn()             -> PositionVector,
	elements: fn()             -> TriangleVector,
	size:     fn()             -> (Index, Index),
	get:      fn(Index, Index) -> Real
}

fn new_laplace_potential_matrix(
	loc:      LocalityType,
	xis:      PositionVector,
	elements: TriangleVector
) -> PotentialMatrix {
	PotentialMatrix {
		pot:      Laplace,
		loc:      loc,
		xis:      ||    xis,
		elements: ||    elements,
		size:     ||    (xis.size(), elements.size()),
		get:      |i,j| if loc == SingleLayer {
			laplacepot_single(xis.get(i), elements.get(j))
		} else {
			laplacepot_double(xis.get(i), elements.get(j))
		}
	}
}

fn new_reyukawa_potential_matrix(
	loc:      LocalityType,
	xis:      PositionVector,
	elements: TriangleVector,
	yuk:      Real
) -> PotentialMatrix {
	PotentialMatrix {
		pot:      ReYukawa,
		loc:      loc,
		xis:      ||    xis,
		elements: ||    elements,
		size:     ||    (xis.size(), elements.size()),
		get:      |i,j| if loc == SingleLayer {
			reyukawapot_single(xis.get(i), elements.get(j), yuk)
		} else {
			reyukawapot_double(xis.get(i), elements.get(j), yuk)
		}
	}
}

fn print_potential_matrix(mat: PotentialMatrix) -> () {
	let (r, c) = mat.size();
	print_index(r); print_string(" x "); print_index(c);
	if mat.pot == Laplace { print_string(" LaplacePotMatrix"); } else { print_string(" ReYukawaPotMatrix"); }
	if mat.loc == SingleLayer { print_string("{SingleLayer}"); } else { print_string("{DoubleLayer}"); }
	print_string("\n");
}

fn @_host_buf_get_real(buf: Buffer, idx: Index) -> Real { bitcast[&[Real]](buf.data)(idx) }
fn @_global_buf_get_real(buf: Buffer, idx: Index) -> Real { bitcast[&[1][Real]](buf.data)(idx) }
fn @_buf_get_real(buf: Buffer, idx: Index) -> Real {
	if buf.device == 0 { _host_buf_get_real(buf, idx) } else { _global_buf_get_real(buf, idx) }
}

fn @_host_buf_set_real(buf: Buffer, idx: Index, val: Real) -> () { bitcast[&mut[Real]](buf.data)(idx) = val }
fn @_global_buf_set_real(buf: Buffer, idx: Index, val: Real) -> () { bitcast[&mut[1][Real]](buf.data)(idx) = val }
fn @_buf_set_real(buf: Buffer, idx: Index, val: Real) -> () {
	if buf.device == 0 { _host_buf_set_real(buf, idx, val) } else { _global_buf_set_real(buf, idx, val) }
}

struct RealVector {
	buf:  fn()            -> Buffer,
	size: fn()            -> Index,
	get:  fn(Index)       -> Real,
	set:  fn(Index, Real) -> ()
}

fn new_real_vector(buf: Buffer, size: Index) -> RealVector {
	RealVector {
		buf:  @||         buf,
		size: @||         size,
		get:  @|idx|      _buf_get_real(buf, idx),
		set:  @|idx, val| _buf_set_real(buf, idx, val)
	}
}

fn fill_real_vector(vec: RealVector, val: Real) -> RealVector {
	for i in range(0, vec.size() as i32) {
		vec.set(i as Index, val)
	}
	vec
}

fn print_real_vector(vec: RealVector) -> () {
	print_index(vec.size()); print_string("-element Vector[Real]:\n");
	for i in range(0, cpu_intrinsics.min(10, vec.size() as i32)) {
		print_string(" "); print_real(vec.get(i as Index)); print_string("\n");
	}
}

fn @_host_buf_get_pos(buf: Buffer, idx: Index) -> Position { bitcast[&[Position]](buf.data)(idx) }
fn @_global_buf_get_pos(buf: Buffer, idx: Index) -> Position { bitcast[&[1][Position]](buf.data)(idx) }
fn @_buf_get_pos(buf: Buffer, idx: Index) -> Position {
	if buf.device == 0 { _host_buf_get_pos(buf, idx) } else { _global_buf_get_pos(buf, idx) }
}

fn @_host_buf_set_pos(buf: Buffer, idx: Index, val: Position) -> () { bitcast[&mut[Position]](buf.data)(idx) = val }
fn @_global_buf_set_pos(buf: Buffer, idx: Index, val: Position) -> () {
	bitcast[&mut[1][Position]](buf.data)(idx) = val
}
fn @_buf_set_pos(buf: Buffer, idx: Index, val: Position) -> () {
	if buf.device == 0 { _host_buf_set_pos(buf, idx, val) } else { _global_buf_set_pos(buf, idx, val) }
}

struct PositionVector {
	buf:  fn()                -> Buffer,
	size: fn()                -> Index,
	get:  fn(Index)           -> Position,
	set:  fn(Index, Position) -> ()
}

fn new_position_vector(buf: Buffer, size: Index) -> PositionVector {
	PositionVector {
		buf:  @||         buf,
		size: @||         size,
		get:  @|idx|      _buf_get_pos(buf, idx),
		set:  @|idx, val| _buf_set_pos(buf, idx, val)
	}
}

fn print_position_vector(vec: PositionVector) -> () {
	print_index(vec.size()); print_string("-element Vector[Position]:\n");
	for i in range(0, cpu_intrinsics.min(10, vec.size() as i32)) {
		print_string(" "); print_position(vec.get(i as Index)); print_string("\n");
	}
}

fn @_host_buf_get_triangle(buf: Buffer, idx: Index) -> Triangle {
	new_triangle(bitcast[&[TrianglePrimitive]](buf.data)(idx))
}

fn @_global_buf_get_triangle(buf: Buffer, idx: Index) -> Triangle {
	new_triangle(bitcast[&[1][TrianglePrimitive]](buf.data)(idx))
}

fn @_buf_get_triangle(buf: Buffer, idx: Index) -> Triangle {
	if buf.device == 0 { _host_buf_get_triangle(buf, idx) } else { _global_buf_get_triangle(buf, idx) }
}

fn @_host_buf_set_triangle(buf: Buffer, idx: Index, val: Triangle) -> () {
	bitcast[&mut[TrianglePrimitive]](buf.data)(idx) = TrianglePrimitive {
		v1: val.v1(),
		v2: val.v2(),
		v3: val.v3()
	}
}

fn @_global_buf_set_triangle(buf: Buffer, idx: Index, val: Triangle) -> () {
	bitcast[&mut[1][TrianglePrimitive]](buf.data)(idx) = TrianglePrimitive {
		v1: val.v1(),
		v2: val.v2(),
		v3: val.v3()
	}
}

fn @_buf_set_triangle(buf: Buffer, idx: Index, val: Triangle) -> () {
	if buf.device == 0 { _host_buf_set_triangle(buf, idx, val) } else { _global_buf_set_triangle(buf, idx, val) }
}

struct TriangleVector {
	buf:  fn()                -> Buffer,
	size: fn()                -> Index,
	get:  fn(Index)           -> Triangle,
	set:  fn(Index, Triangle) -> (),
}

fn new_triangle_vector(buf: Buffer, size: Index) -> TriangleVector {
	TriangleVector {
		buf:  @||         buf,
		size: @||         size,
		get:  @|idx|      _buf_get_triangle(buf, idx),
		set:  @|idx, val| _buf_set_triangle(buf, idx, val)
	}
}

fn print_triangle_vector(vec: TriangleVector) -> () {
	print_index(vec.size()); print_string("-element Vector[Triangle]:\n");
	for i in range(0, cpu_intrinsics.min(10, vec.size() as i32)) {
		print_string(" "); print_triangle(vec.get(i as Index)); print_string("\n");
	}
}

fn @linear_system_context(
	A:    PotentialMatrix,
	x:    RealVector,
	b:    RealVector,
	body: fn(PotentialMatrix, RealVector, RealVector) -> ()
) -> () {
	with A in potential_matrix_context(A) {
		with x in real_vector_context(x) {
			with b in real_vector_context(b) {
				@@body(A, x, b)
			}
		}
	}
}

fn potmat_mul(dst: RealVector, A: PotentialMatrix, x: RealVector) -> () {
	with A, x, dst in linear_system_context(A, x, dst) {
		for i in each_potential_matrix_row(A) {
			let mut sum = zero;
			for j in range(0, A.size()(1) as i32) {
				sum += A.get(i as Index, j as Index) * x.get(j as Index)
			}
			dst.set(i as Index, sum);
		}
	}
}
