fn @cross(u: Position, v: Position) -> Position {
	Position {
		x: u.y * v.z - u.z * v.y,
		y: u.x * v.z - u.z * v.x,
		z: u.x * v.y - u.y * v.x
	}
}

fn @dot(u: Position, v: Position) -> Real {
	u.x * v.x + u.y * v.y + u.z * v.z
}

fn @euclidean(u: Position, v: Position) -> Real {
	let dx = u.x - v.x;
	let dy = u.y - v.y;
	let dz = u.z - v.z;
	math.sqrt(dx * dx + dy * dy + dz * dz)
}

fn @vecnorm(u: Position) -> Real {
	math.sqrt(vecnorm2(u))
}

fn @vecnorm2(u: Position) -> Real {
	dot(u, u)
}
